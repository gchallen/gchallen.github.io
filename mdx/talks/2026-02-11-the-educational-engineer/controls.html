<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Presenter View</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    background: #1a1a1a;
    color: #f5f5f0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    padding: 2rem;
  }

  .container {
    width: 100%;
    max-width: 900px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  /* Waiting screen */
  #waiting-screen {
    text-align: center;
  }

  #waiting-screen h1 {
    font-size: 2.5rem;
    font-weight: 300;
    margin-bottom: 1rem;
  }

  #waiting-screen .hint {
    font-size: 1.2rem;
    color: #888;
  }

  /* Presenter screen */
  #presenter-screen {
    display: none;
    flex-direction: column;
    align-items: center;
    width: 100%;
  }

  .section-label {
    font-size: 1.4rem;
    color: #888;
    margin-bottom: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }

  .section-title {
    font-size: 3rem;
    font-weight: 300;
    text-align: center;
    line-height: 1.3;
    margin-bottom: 2rem;
    color: #fff;
  }

  .timers {
    display: flex;
    gap: 4rem;
    align-items: flex-start;
    margin-bottom: 2rem;
  }

  .timer-block {
    text-align: center;
  }

  .timer-label {
    font-size: 1.2rem;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    margin-bottom: 0.3rem;
  }

  .timer-display {
    font-size: 6rem;
    font-variant-numeric: tabular-nums;
    font-weight: 300;
    letter-spacing: 0.03em;
    line-height: 1;
  }

  .timer-display.on-track { color: #28a745; }
  .timer-display.warning { color: #c8860a; }
  .timer-display.danger { color: #c9302c; }

  .timer-display.secondary {
    font-size: 4rem;
    color: #888;
  }

  .slide-title-block {
    flex: 1;
    min-width: 0;
    text-align: left;
  }

  .slide-title-text {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .slide-notes {
    width: 100%;
    text-align: left;
    margin-bottom: 1.5rem;
    padding: 0 0.5rem;
  }

  .slide-notes ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  .slide-notes li {
    font-size: 1.5rem;
    color: #ccc;
    padding: 0.3rem 0;
    line-height: 1.4;
  }

  .slide-notes li::before {
    content: "›";
    color: #5BC4D4;
    font-weight: 700;
    margin-right: 0.6rem;
  }

  /* Practice controls */
  .practice-controls {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 1rem;
    margin-top: 1rem;
  }

  .practice-controls.visible {
    display: flex;
  }

  .recording-indicator {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    font-size: 1.2rem;
    color: #c9302c;
    height: 1.5rem;
  }

  .recording-dot {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #d9534f;
    display: none;
  }

  .recording-dot.active {
    display: block;
    animation: pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.4; transform: scale(0.8); }
  }

  .btn {
    font-size: 1.4rem;
    padding: 0.8rem 2.5rem;
    border-radius: 50px;
    border: none;
    cursor: pointer;
    transition: all 0.2s;
    font-family: inherit;
    font-weight: 500;
    background: #28a745;
    color: white;
  }

  .btn:hover { transform: scale(1.05); }
  .btn:active { transform: scale(0.98); }
  .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
  .btn.stop { background: #c9302c; }
  .btn.download { background: #6c757d; }

  .btn-row {
    display: flex;
    gap: 1rem;
  }

  /* Done screen */
  #done-screen {
    display: none;
    flex-direction: column;
    align-items: center;
    width: 100%;
  }

  #done-screen h2 {
    font-size: 2.5rem;
    font-weight: 300;
    margin-bottom: 1.5rem;
  }

  .summary-table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 1.5rem;
    font-variant-numeric: tabular-nums;
  }

  .summary-table th,
  .summary-table td {
    padding: 0.5rem 0.8rem;
    text-align: left;
    border-bottom: 1px solid #333;
  }

  .summary-table th {
    color: #888;
    font-weight: 500;
    font-size: 1rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .summary-table td { font-size: 1.1rem; }

  .summary-table .num { text-align: center; color: #888; }
  .summary-table .time { text-align: right; font-variant-numeric: tabular-nums; }
  .summary-table .over { color: #c9302c; }
  .summary-table .under { color: #28a745; }
  .summary-table .on-time { color: #888; }

  .summary-table tr.total-row td {
    border-top: 2px solid #2a7ab5;
    font-weight: 600;
    padding-top: 0.75rem;
  }

  .done-actions {
    display: flex;
    gap: 1rem;
  }

  .mode-indicator {
    position: fixed;
    top: 1rem;
    right: 1rem;
    font-size: 0.9rem;
    color: #666;
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }

  .mode-indicator.practice { color: #c9302c; }
</style>
</head>
<body>

<div class="mode-indicator" id="mode-indicator"></div>

<div class="container">
  <div id="waiting-screen">
    <h1>Presenter View</h1>
    <div class="hint">Waiting for slides to connect...</div>
    <div class="hint" style="margin-top: 0.5rem;">Open the presenter slides at <a href="presenter.html" style="color: #2a7ab5;">presenter.html</a></div>
  </div>

  <div id="presenter-screen">
    <div class="section-label" id="section-label"></div>
    <div class="section-title" id="section-title"></div>
    <div class="timers">
      <div class="timer-block">
        <div class="timer-label">Section</div>
        <div class="timer-display" id="section-timer">0:00</div>
      </div>
      <div class="timer-block">
        <div class="timer-label">Total</div>
        <div class="timer-display" id="total-timer">0:00</div>
      </div>
      <div class="timer-block">
        <div class="timer-label">Buffer</div>
        <div class="timer-display" id="buffer-timer">+0:00</div>
      </div>
      <div class="timer-block">
        <div class="timer-label">Clock</div>
        <div class="timer-display" id="clock"></div>
      </div>
    </div>
    <div class="timers" style="gap: 3rem;">
      <div class="timer-block">
        <div class="timer-label">Slide</div>
        <div class="timer-display secondary" id="current-slide">-</div>
      </div>
      <div class="timer-block">
        <div class="timer-label">Total Slides</div>
        <div class="timer-display secondary" id="total-slides">-</div>
      </div>
      <div class="timer-block">
        <div class="timer-label">Fragments Left</div>
        <div class="timer-display secondary" id="fragments-left">-</div>
      </div>
      <div class="timer-block slide-title-block">
        <div class="timer-label">Slide</div>
        <div class="timer-display secondary slide-title-text" id="slide-title">-</div>
      </div>
    </div>
    <div class="slide-notes" id="slide-notes"></div>

    <div id="presenter-start-controls" style="margin-top: 1rem;">
      <button class="btn" id="presenter-start-btn">Start Timer</button>
    </div>

    <div class="practice-controls" id="practice-controls">
      <div class="recording-indicator">
        <div class="recording-dot" id="recording-dot"></div>
        <span id="recording-label"></span>
      </div>
      <div class="btn-row" id="practice-buttons">
        <button class="btn" id="start-btn">Start Recording</button>
      </div>
    </div>
  </div>

  <div id="done-screen">
    <h2>Practice Complete</h2>
    <table class="summary-table" id="summary-table">
      <thead>
        <tr>
          <th class="num">#</th>
          <th>Section</th>
          <th class="time">Actual</th>
          <th class="time">Target</th>
          <th class="time">Diff</th>
        </tr>
      </thead>
      <tbody id="summary-body"></tbody>
    </table>
    <div class="done-actions">
      <button class="btn download" id="download-zip-btn">Download ZIP</button>
      <button class="btn download" id="download-yaml-btn">Download YAML</button>
      <button class="btn" id="restart-btn">Reset</button>
    </div>
  </div>
</div>

<script>
(function() {
  // Section definitions - maps to slides.yaml structure
  // Each section starts at a section-slide and includes subsequent content slides
  // Slide indices: 0=title, 1=section-frequent-assessment, 2=section-questioner, etc.
  const sections = [
    { title: "The Educational Engineer", targetSec: 120, startSlide: 0 },
    { title: "Frequent Small Assessment", targetSec: 420, startSlide: 1 },
    { title: "Solve, Learn, Repeat", targetSec: 300, startSlide: 2 },
    { title: "Through the Pandemic", targetSec: 300, startSlide: 3 },
    { title: "Interactive Walkthroughs", targetSec: 300, startSlide: 5 },
    { title: "The Trajectory", targetSec: 180, startSlide: 6 },
    { title: "AI v. the Assignment", targetSec: 300, startSlide: 7 },
    { title: "Your Ideas Talking", targetSec: 300, startSlide: 9 },
    { title: "Conversational Assessment", targetSec: 300, startSlide: 10 },
    { title: "The Horizon", targetSec: 600, startSlide: 11 },
  ];

  // Precompute cumulative targets
  let cumulative = 0;
  for (const s of sections) {
    cumulative += s.targetSec;
    s.cumulativeTarget = cumulative;
  }

  // Check for practice mode
  const urlParams = new URLSearchParams(window.location.search);
  const isPracticeMode = urlParams.get('practice') === 'true';

  // DOM refs
  const modeIndicator = document.getElementById('mode-indicator');
  const waitingScreen = document.getElementById('waiting-screen');
  const presenterScreen = document.getElementById('presenter-screen');
  const doneScreen = document.getElementById('done-screen');
  const practiceControls = document.getElementById('practice-controls');
  const practiceButtons = document.getElementById('practice-buttons');

  const sectionLabel = document.getElementById('section-label');
  const sectionTitle = document.getElementById('section-title');
  const sectionTimerEl = document.getElementById('section-timer');
  const totalTimerEl = document.getElementById('total-timer');
  const bufferTimerEl = document.getElementById('buffer-timer');
  const clockEl = document.getElementById('clock');
  const dotEl = document.getElementById('recording-dot');
  const labelEl = document.getElementById('recording-label');
  const summaryBody = document.getElementById('summary-body');

  const currentSlideEl = document.getElementById('current-slide');
  const totalSlidesEl = document.getElementById('total-slides');
  const fragmentsLeftEl = document.getElementById('fragments-left');
  const slideTitleEl = document.getElementById('slide-title');
  const presenterStartControls = document.getElementById('presenter-start-controls');
  const presenterStartBtn = document.getElementById('presenter-start-btn');
  const slideNotesEl = document.getElementById('slide-notes');

  // Speaker notes per slide (0-indexed)
  const slideNotes = [
    // 0: title
    ["I'm an educational engineer — I build technology to help students learn",
     "Sydney connection: Bilgola Beach, summer 2010, thanks to David Kinley",
     "Harvard PhD → Buffalo (NSF CAREER, ~$3M funding) → Illinois teaching pivot 2017"],
    // 1: follow-along
    ["Share the slides link — audience can follow along on their devices"],
    // 2: overview-grid
    ["Nine sections: six past, three present, closing with the future",
     "Past → Present → Future arc"],
    // 3: section-frequent-assessment
    [],
    // 4: high-stakes-problem
    ["Students cram, forget, fall behind — one bad day = catastrophic",
     "Limited data about understanding — you find out too late",
     "Infrequent assessment provides no structure"],
    // 5: cramming-spikes
    ["Cramming spikes before midterm and final",
     "No incentive to keep up between exams"],
    // 6: weekly-quizzes
    ["No midterm, no final — weekly quizzes worth 2.5% each",
     "Most significant untimed assessment is only 4%",
     "Entirely eliminated high-stakes assessment"],
    // 7: fsa-reasons
    ["Students keep up — no incentive to procrastinate",
     "Immediate feedback within a week, enables early intervention",
     "Generous drops, retakes, catch-up grading — universal design",
     "Reduces stress without formal accommodations"],
    // 8: assessment-comparison
    ["Fall 2017: code in proctored setting ONCE — on a paper exam",
     "Fall 2024: weekly proctored computer quizzes",
     "15 hours proctored vs 3–4 previously",
     "Not grade inflation — better course design"],
    // 9: cbtf
    ["Computer-based testing facility — proctored, autograded, purpose-built",
     "→ Frequent assessment creates demand for problems"],
    // 10: section-questioner
    [],
    // 11: spec-vs-tests
    ["Authoring bottleneck: test suites take hours to write",
     "269-line spec → 645-line test suite",
     "Need to cover corner cases, prevent memoization, handle multiple approaches"],
    // 12: questioner-insight
    ["Found myself writing mini-solutions inside test code",
     "When autograding, the solution is known — fundamentally different from software testing",
     "Why maintain three sources of truth when two should suffice?"],
    // 13: mutation-example
    ["Source code mutation: flip <, change + to -, etc.",
     "Test each mutant to ensure generated tests catch the error",
     "If a mutant slips through, strengthen tests and retry"],
    // 14: questioner-scale
    ["Old: hours per problem, unknown accuracy",
     "New: several problems per hour, validated accuracy",
     "700+ problems since Fall 2020 — published at SIGCSE 2025"],
    // 15: programming-exercises
    ["Code quality analysis: complexity, dead code, style, efficiency",
     "Not just 'does it work?' but 'is it good?'",
     "Instant feedback — addresses classic autograding criticism"],
    // 16: debugging-exercises
    ["Mutates real student code to create buggy versions",
     "Students find and fix without rewriting — forces reading others' code",
     "→ Had tools and assessment, but still doing lectures. Then a crisis."],
    // 17: section-pandemic-pivot
    [],
    // 18: fall-2019
    ["The before picture: 900 students, lectures 3x/week",
     "No single pace works for a large diverse class",
     "Watching someone code breeds overconfidence"],
    // 19: spring-2020
    ["Remote lecturing clearly even less effective",
     "If rebuilding for remote, don't replicate what wasn't working"],
    // 20: pandemic-daily-lessons
    ["Replaced lectures with async daily lessons — 5 per week",
     "Text + playgrounds + walkthroughs + practice problems",
     "Self-paced: beginners take longer, experienced move fast"],
    // 21: kept-it
    ["Post-pandemic: did NOT go back to lectures",
     "Enrollment 900 → 1,400 with strong outcomes",
     "The pandemic was a crisis — I turned it into an opportunity"],
    // 22: dawn-dusk-tutoring
    ["Dawn-to-dusk online tutoring support",
     "17,000 questions answered Fall 2022 — 14 per student",
     "Far more interaction than any lecture could support",
     "→ Needed to replace live coding — led to walkthroughs"],
    // 23: section-walkthroughs
    [],
    // 24: walkthrough-origin
    ["Clicked on video to edit code — video just paused",
     "Video only delivers pixels, not code",
     "I knew I could build something better"],
    // 25: walkthrough-demo
    ["Animated editor replay with audio narration",
     "NOT a video — actual code in a real editor",
     "Students can pause, edit, run, submit to autograder"],
    // 26: walkthrough-recording
    ["Recorded in browser, right on the lesson page",
     "No external tools — instructor sees surrounding context",
     "Low barrier: a few minutes to record, immediately available"],
    // 27: decentering
    ["~300 people have recorded walkthroughs since Fall 2020",
     "2,540+ walkthroughs across the course",
     "I fail to represent the diversity of this field — walkthroughs let me invite others in"],
    // 28: student-preferences
    ["Students develop real preferences — align with identity",
     "Multiple voices change who feels welcome",
     "Published: Zhou, Paquette & Challen, SIGCSE 2025"],
    // 29: section-trajectory
    [],
    // 30: trajectory-results
    ["700 → 1,200+ students, Java and Kotlin",
     "50% → 80% A-range, 5% → 2.5% failure",
     "15,000+ students taught, 2,200+ course staff",
     "Performance gaps between genders and majors shrunk significantly"],
    // 31: trajectory-dissemination
    ["learncs.online — free, public, used worldwide",
     "High school outreach, community college pilot",
     "Every innovation connects — integrated system, not one-off tools",
     "→ The pandemic was one crisis. Now the second."],
    // 32: section-ai-broke
    [],
    // 33: ai-demo
    ["Tested Claude on CS 124 Android project, Summer 2025",
     "Gave only test suites — not even written instructions",
     "Completed entire assignment with almost no human intervention"],
    // 34: assignment-pipeline
    ["Traditional: instructor idea → spec → student writes code → autograder",
     "Spec is central — but makes agent's job trivially easy",
     "Years making specs clearer inadvertently helped AI"],
    // 35: blurred-spec
    ["Fall 2025: tried blurring spec while telling students to use Claude",
     "Staff tested: told Claude 'make the tests compile' — finished the project",
     "This approach failed"],
    // 36: student-quotes
    ["Students: 'everyone is using AI', 'just asked Claude to do everything'",
     "Had to do something different",
     "→ So we flipped the model"],
    // 37: section-two-lane
    [],
    // 38: idea-pipeline
    ["Old: instructor idea → instructor spec → student writes code",
     "New: student idea → student spec → AI writes code",
     "Everyone builds their own Android app — My Project",
     "Machine Problem → Machine Project → My Project"],
    // 39: two-lanes
    ["Lane 1: Classical programming — 70%, proctored, no AI",
     "Lane 2: AI-collaborative — My Project with Claude Code",
     "Writing code by hand = mental training like weightlifting",
     "15 hours proctored — we know what students actually know"],
    // 40: section-conversation
    [],
    // 41: autograde-everything
    ["AI makes written assessment vulnerable",
     "Oral exams don't scale with 1,200 students",
     "Need assessment that scales and AI can't fake"],
    // 42: conversation-demo
    ["Oral-exam-style via chat with AI interviewer",
     "Generation, not recognition — explain in your own words",
     "Running at usingandunderstanding.ai"],
    // 43: multi-agent-architecture
    ["Interviewer: conducts conversation, doesn't see rubric or answers",
     "Evaluator: analyses against rubrics, sends guidance",
     "Adversarial testing with personas — validated robustness",
     "→ That's where I am. Let me close with where this is headed."],
    // 44: section-horizon
    [],
    // 45: horizon-thoughts
    ["The future of CS education in an AI world",
     "Big open questions about what comes next"],
    // 46: lets-chat
    ["Thank you! Let's chat."],
  ];

  const startBtn = document.getElementById('start-btn');
  const downloadZipBtn = document.getElementById('download-zip-btn');
  const downloadYamlBtn = document.getElementById('download-yaml-btn');
  const restartBtn = document.getElementById('restart-btn');

  // State
  let currentSlideH = 0;
  let currentSlideV = 0;
  let currentSectionIndex = 0;
  let totalStartTime = 0;
  let sectionStartTime = 0;
  let timerInterval = null;
  let mediaRecorder = null;
  let audioChunks = [];
  let sectionTimes = []; // actual seconds per section
  let state = 'WAITING'; // WAITING | PRESENTING | RECORDING | DONE
  let connected = false;

  // Broadcast state
  let broadcastTitle = '';
  let broadcastTotalSlides = 0;
  let broadcastCurrentSlide = 0;
  let broadcastFragmentStepsTotal = 0;
  let broadcastFragmentStepsVisible = 0;
  let broadcastSectionIndex = 0;
  let broadcastSectionName = '';
  let broadcastSectionCount = 0;

  // Set up mode indicator
  if (isPracticeMode) {
    modeIndicator.textContent = 'Practice Mode';
    modeIndicator.classList.add('practice');
    practiceControls.classList.add('visible');
    presenterStartControls.style.display = 'none';
  } else {
    modeIndicator.textContent = 'Presenter Mode';
  }

  presenterStartBtn.addEventListener('click', () => {
    startPresenting();
    presenterStartControls.style.display = 'none';
  });

  function formatTime(seconds) {
    const m = Math.floor(seconds / 60);
    const s = Math.floor(seconds % 60);
    return `${m}:${s.toString().padStart(2, '0')}`;
  }

  function formatTimeWithSign(seconds, alwaysSign) {
    const absSeconds = Math.abs(seconds);
    const m = Math.floor(absSeconds / 60);
    const s = Math.floor(absSeconds % 60);
    const time = `${m}:${s.toString().padStart(2, '0')}`;

    if (seconds < 0) return `-${time}`;
    if (alwaysSign) return `+${time}`;
    return time;
  }

  function getSectionForSlide(indexh) {
    // Find which section this slide belongs to
    for (let i = sections.length - 1; i >= 0; i--) {
      if (indexh >= sections[i].startSlide) {
        return i;
      }
    }
    return 0;
  }

  function updateDisplay() {
    const sec = sections[currentSectionIndex];
    sectionLabel.textContent = broadcastSectionCount > 0
      ? `Section ${broadcastSectionIndex + 1} of ${broadcastSectionCount}`
      : `Section ${currentSectionIndex + 1} of ${sections.length}`;
    sectionTitle.textContent = broadcastSectionName || broadcastTitle || sec.title;

    currentSlideEl.textContent = broadcastCurrentSlide || '-';
    totalSlidesEl.textContent = broadcastTotalSlides || '-';
    fragmentsLeftEl.textContent = broadcastFragmentStepsTotal > 0
      ? broadcastFragmentStepsTotal - broadcastFragmentStepsVisible
      : '-';
    slideTitleEl.textContent = broadcastTitle || '-';

    // Show speaker notes for current slide (0-indexed)
    const noteIndex = broadcastCurrentSlide ? broadcastCurrentSlide - 1 : -1;
    const notes = (noteIndex >= 0 && noteIndex < slideNotes.length) ? slideNotes[noteIndex] : [];
    if (notes.length > 0) {
      slideNotesEl.innerHTML = '<ul>' + notes.map(n => `<li>${n}</li>`).join('') + '</ul>';
    } else {
      slideNotesEl.innerHTML = '';
    }

    // Initialize timers before presenting starts
    if (state !== 'PRESENTING' && state !== 'RECORDING') {
      sectionTimerEl.textContent = sec ? formatTime(sec.targetSec) : '0:00';
      sectionTimerEl.classList.remove('warning', 'danger');
      sectionTimerEl.classList.add('on-track');
      totalTimerEl.textContent = '0:00';
      totalTimerEl.classList.remove('warning', 'danger');
      totalTimerEl.classList.add('on-track');
      bufferTimerEl.textContent = '+0:00';
      bufferTimerEl.classList.remove('warning', 'danger');
      bufferTimerEl.classList.add('on-track');
    }
  }

  function updateClock() {
    const now = new Date();
    const hours = now.getHours();
    const minutes = now.getMinutes().toString().padStart(2, '0');
    clockEl.textContent = `${hours}:${minutes}`;
  }

  function updateTimers() {
    if (state !== 'PRESENTING' && state !== 'RECORDING') return;

    const now = Date.now();
    const currentSessionElapsed = (now - sectionStartTime) / 1000;
    const sectionTotal = (sectionTimes[currentSectionIndex] || 0) + currentSessionElapsed;
    const totalElapsed = (now - totalStartTime) / 1000;
    const sec = sections[currentSectionIndex];

    // Section timer: countdown from target (accumulated time across all visits)
    const sectionRemaining = sec.targetSec - sectionTotal;
    sectionTimerEl.textContent = formatTimeWithSign(sectionRemaining, false);

    // Section coloring: green > 60s, yellow 0-60s, red < 0
    sectionTimerEl.classList.remove('on-track', 'warning', 'danger');
    if (sectionRemaining < 0) {
      sectionTimerEl.classList.add('danger');
    } else if (sectionRemaining < 60) {
      sectionTimerEl.classList.add('warning');
    } else {
      sectionTimerEl.classList.add('on-track');
    }

    // Total timer: count up
    totalTimerEl.textContent = formatTime(totalElapsed);

    // Calculate buffer:
    // - Completed sections: sum of (target - actual)
    // - Current section: only negative contributes (when over time)
    // - Future sections: assume on time (no contribution)
    let buffer = 0;
    for (let i = 0; i < currentSectionIndex; i++) {
      buffer += sections[i].targetSec - (sectionTimes[i] || 0);
    }
    // Current section: only count overrun (negative remaining time)
    const currentOverrun = Math.min(0, sectionRemaining);
    buffer += currentOverrun;

    // Total coloring: based on buffer
    totalTimerEl.classList.remove('on-track', 'warning', 'danger');
    if (buffer < -30) {
      totalTimerEl.classList.add('danger');
    } else if (buffer < 30) {
      totalTimerEl.classList.add('warning');
    } else {
      totalTimerEl.classList.add('on-track');
    }

    // Buffer timer: +/- time ahead/behind
    bufferTimerEl.textContent = formatTimeWithSign(buffer, true);
    bufferTimerEl.classList.remove('on-track', 'warning', 'danger');
    if (buffer < -30) {
      bufferTimerEl.classList.add('danger');
    } else if (Math.abs(buffer) < 30) {
      bufferTimerEl.classList.add('warning');
    } else {
      bufferTimerEl.classList.add('on-track');
    }
  }

  function handleSlideChange(indexh, indexv) {
    currentSlideH = indexh;
    currentSlideV = indexv;

    const newSectionIndex = broadcastSectionIndex;

    // If section changed and we're timing, accumulate the section time
    if (newSectionIndex !== currentSectionIndex && (state === 'PRESENTING' || state === 'RECORDING')) {
      const now = Date.now();
      const sessionElapsed = (now - sectionStartTime) / 1000;
      sectionTimes[currentSectionIndex] = (sectionTimes[currentSectionIndex] || 0) + sessionElapsed;
      sectionStartTime = now;
    }

    currentSectionIndex = newSectionIndex;
    updateDisplay();

    // Check if we've finished (last slide)
    // This would need knowledge of total slides - for now we rely on manual stop
  }

  function startPresenting() {
    state = 'PRESENTING';
    totalStartTime = Date.now();
    sectionStartTime = Date.now();
    sectionTimes = new Array(sections.length).fill(0);
    timerInterval = setInterval(updateTimers, 100);
    updateTimers();
  }

  async function startRecording() {
    state = 'RECORDING';
    totalStartTime = Date.now();
    sectionStartTime = Date.now();
    sectionTimes = new Array(sections.length).fill(0);
    audioChunks = [];

    // Start recording
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: { echoCancellation: false, noiseSuppression: true, autoGainControl: true }
      });

      const mimeType = MediaRecorder.isTypeSupported('audio/webm;codecs=opus')
        ? 'audio/webm;codecs=opus'
        : 'audio/webm';

      mediaRecorder = new MediaRecorder(stream, { mimeType });
      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) audioChunks.push(e.data);
      };
      mediaRecorder.start(1000);

      dotEl.classList.add('active');
      labelEl.textContent = 'Recording';
    } catch (e) {
      dotEl.classList.remove('active');
      labelEl.textContent = 'No mic access';
    }

    // Update button
    practiceButtons.innerHTML = '<button class="btn stop" id="stop-btn">Stop Recording</button>';
    document.getElementById('stop-btn').addEventListener('click', finishPractice);

    timerInterval = setInterval(updateTimers, 100);
    updateTimers();
  }

  function finishPractice() {
    // Accumulate final section time
    const now = Date.now();
    const sessionElapsed = (now - sectionStartTime) / 1000;
    sectionTimes[currentSectionIndex] = (sectionTimes[currentSectionIndex] || 0) + sessionElapsed;

    state = 'DONE';
    clearInterval(timerInterval);

    // Stop recording
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
      mediaRecorder.stream.getTracks().forEach(t => t.stop());
    }
    dotEl.classList.remove('active');
    labelEl.textContent = '';

    // Build summary
    presenterScreen.style.display = 'none';
    doneScreen.style.display = 'flex';

    summaryBody.innerHTML = '';
    let totalActual = 0;
    let totalTarget = 0;

    for (let i = 0; i < sections.length; i++) {
      const sec = sections[i];
      const actual = sectionTimes[i] || 0;
      totalActual += actual;
      totalTarget += sec.targetSec;

      const diff = actual - sec.targetSec;
      const diffAbs = Math.abs(diff);
      let diffClass, diffText;
      if (actual === 0) {
        diffClass = 'on-time';
        diffText = '—';
      } else if (Math.abs(diff) < 5) {
        diffClass = 'on-time';
        diffText = '—';
      } else if (diff > 0) {
        diffClass = 'over';
        diffText = `+${formatTime(diffAbs)}`;
      } else {
        diffClass = 'under';
        diffText = `−${formatTime(diffAbs)}`;
      }

      const tr = document.createElement('tr');
      tr.innerHTML =
        `<td class="num">${i + 1}</td>` +
        `<td>${sec.title}</td>` +
        `<td class="time">${actual > 0 ? formatTime(actual) : '—'}</td>` +
        `<td class="time">${formatTime(sec.targetSec)}</td>` +
        `<td class="time ${diffClass}">${diffText}</td>`;
      summaryBody.appendChild(tr);
    }

    // Total row
    const totalDiff = totalActual - totalTarget;
    const totalDiffAbs = Math.abs(totalDiff);
    let totalDiffClass, totalDiffText;
    if (Math.abs(totalDiff) < 5) {
      totalDiffClass = 'on-time';
      totalDiffText = '—';
    } else if (totalDiff > 0) {
      totalDiffClass = 'over';
      totalDiffText = `+${formatTime(totalDiffAbs)}`;
    } else {
      totalDiffClass = 'under';
      totalDiffText = `−${formatTime(totalDiffAbs)}`;
    }

    const totalRow = document.createElement('tr');
    totalRow.className = 'total-row';
    totalRow.innerHTML =
      `<td class="num"></td>` +
      `<td>Total</td>` +
      `<td class="time">${formatTime(totalActual)}</td>` +
      `<td class="time">${formatTime(totalTarget)}</td>` +
      `<td class="time ${totalDiffClass}">${totalDiffText}</td>`;
    summaryBody.appendChild(totalRow);

    // Show/hide download buttons
    downloadZipBtn.style.display = audioChunks.length > 0 ? 'inline-block' : 'none';
  }

  function reset() {
    state = 'PRESENTING';
    doneScreen.style.display = 'none';
    presenterScreen.style.display = 'flex';

    if (isPracticeMode) {
      practiceButtons.innerHTML = '<button class="btn" id="start-btn">Start Recording</button>';
      document.getElementById('start-btn').addEventListener('click', startRecording);
    }

    // Restart timing from current position
    totalStartTime = Date.now();
    sectionStartTime = Date.now();
    sectionTimes = new Array(sections.length).fill(0);
    timerInterval = setInterval(updateTimers, 100);
    updateTimers();
  }

  // Event handlers
  startBtn.addEventListener('click', startRecording);
  restartBtn.addEventListener('click', reset);

  function getStamp() {
    const now = new Date();
    return `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}-${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}`;
  }

  function buildYaml() {
    const stamp = getStamp();
    let totalActual = 0;
    let totalTarget = 0;
    let yamlSections = '';
    for (let i = 0; i < sections.length; i++) {
      const sec = sections[i];
      const actual = Math.round(sectionTimes[i] || 0);
      totalActual += actual;
      totalTarget += sec.targetSec;
      const diff = actual - sec.targetSec;
      yamlSections +=
        `  - num: ${i + 1}\n` +
        `    title: "${sec.title}"\n` +
        `    actual_sec: ${actual}\n` +
        `    target_sec: ${sec.targetSec}\n` +
        `    diff_sec: ${diff}\n`;
    }
    return (
      `date: "${stamp.replace('_', 'T')}"\n` +
      `total_actual_sec: ${totalActual}\n` +
      `total_target_sec: ${totalTarget}\n` +
      `sections:\n` +
      yamlSections
    );
  }

  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Minimal ZIP builder
  function buildZip(files) {
    const enc = new TextEncoder();
    let offset = 0;
    const centralDir = [];
    const parts = [];

    for (const { name, data } of files) {
      const nameBytes = enc.encode(name);
      const localHeader = new Uint8Array(30 + nameBytes.length);
      const lv = new DataView(localHeader.buffer);
      lv.setUint32(0, 0x04034b50, true);
      lv.setUint16(4, 20, true);
      lv.setUint16(8, 0, true);
      lv.setUint32(18, data.byteLength, true);
      lv.setUint32(22, data.byteLength, true);
      lv.setUint16(26, nameBytes.length, true);
      localHeader.set(nameBytes, 30);

      const cdEntry = new Uint8Array(46 + nameBytes.length);
      const cv = new DataView(cdEntry.buffer);
      cv.setUint32(0, 0x02014b50, true);
      cv.setUint16(4, 20, true);
      cv.setUint16(6, 20, true);
      cv.setUint16(10, 0, true);
      cv.setUint32(20, data.byteLength, true);
      cv.setUint32(24, data.byteLength, true);
      cv.setUint16(28, nameBytes.length, true);
      cv.setUint32(42, offset, true);
      cdEntry.set(nameBytes, 46);

      parts.push(localHeader, new Uint8Array(data));
      centralDir.push(cdEntry);
      offset += localHeader.byteLength + data.byteLength;
    }

    const cdOffset = offset;
    let cdSize = 0;
    for (const e of centralDir) { cdSize += e.byteLength; parts.push(e); }

    const eocd = new Uint8Array(22);
    const ev = new DataView(eocd.buffer);
    ev.setUint32(0, 0x06054b50, true);
    ev.setUint16(8, files.length, true);
    ev.setUint16(10, files.length, true);
    ev.setUint32(12, cdSize, true);
    ev.setUint32(16, cdOffset, true);
    parts.push(eocd);

    return new Blob(parts, { type: 'application/zip' });
  }

  downloadYamlBtn.addEventListener('click', () => {
    const yaml = buildYaml();
    const blob = new Blob([yaml], { type: 'text/yaml' });
    downloadBlob(blob, `talk-practice-${getStamp()}.yaml`);
  });

  downloadZipBtn.addEventListener('click', async () => {
    const stamp = getStamp();
    const yaml = buildYaml();
    const yamlBytes = new TextEncoder().encode(yaml);

    const mimeType = mediaRecorder ? mediaRecorder.mimeType : 'audio/webm';
    const audioBlob = new Blob(audioChunks, { type: mimeType });
    const audioBuffer = await audioBlob.arrayBuffer();

    const zip = buildZip([
      { name: `${stamp}.yaml`, data: yamlBytes.buffer },
      { name: `${stamp}.webm`, data: audioBuffer }
    ]);
    downloadBlob(zip, `talk-practice-${stamp}.zip`);
  });

  // BroadcastChannel for sync with main slides
  const syncChannel = new BroadcastChannel('reveal-sync');

  syncChannel.onmessage = (event) => {
    const data = event.data;

    if (data.type === 'slidechanged') {
      // Store broadcast data
      if (data.title !== undefined) broadcastTitle = data.title;
      if (data.totalSlides !== undefined) broadcastTotalSlides = data.totalSlides;
      if (data.currentSlide !== undefined) broadcastCurrentSlide = data.currentSlide;
      if (data.fragmentStepsTotal !== undefined) broadcastFragmentStepsTotal = data.fragmentStepsTotal;
      if (data.fragmentStepsVisible !== undefined) broadcastFragmentStepsVisible = data.fragmentStepsVisible;
      if (data.sectionIndex !== undefined) broadcastSectionIndex = data.sectionIndex;
      if (data.sectionName !== undefined) broadcastSectionName = data.sectionName;
      if (data.sectionCount !== undefined) broadcastSectionCount = data.sectionCount;

      if (!connected) {
        connected = true;
        waitingScreen.style.display = 'none';
        presenterScreen.style.display = 'flex';
        updateDisplay();
      }

      handleSlideChange(data.indexh, data.indexv);
    }
  };

  // Keyboard navigation - send commands to main slides
  document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    if (state === 'DONE') return;

    if (e.code === 'ArrowRight' || e.code === 'Space' || e.code === 'PageUp') {
      e.preventDefault();
      syncChannel.postMessage({ type: 'navigate', direction: 'next' });
    } else if (e.code === 'ArrowLeft' || e.code === 'PageDown') {
      e.preventDefault();
      syncChannel.postMessage({ type: 'navigate', direction: 'prev' });
    } else if (e.code === 'ArrowUp') {
      e.preventDefault();
      syncChannel.postMessage({ type: 'navigate', direction: 'up' });
    } else if (e.code === 'ArrowDown') {
      e.preventDefault();
      syncChannel.postMessage({ type: 'navigate', direction: 'down' });
    }
  });

  // Start clock updates
  updateClock();
  setInterval(updateClock, 1000);

})();
</script>
</body>
</html>
